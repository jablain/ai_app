# Project-local environment for ai_app

if [ -d .venv ]; then
  # Manually add the venv's bin to the PATH
  PATH_add .venv/bin
  
  # --- .bashrc Integration for (.venv) Prefix ---
  # EXPORT THE VIRTUAL_ENV VARIABLE.
  # This is the "signal" variable. The 'direnv hook' in .bashrc
  # (which must be active) loads this variable into the shell.
  #
  # NOTE FOR FUTURE REFERENCE (The .bashrc Saga):
  # The standard 'direnv hook' failed to automatically modify our
  # shell prompt (PS1), likely due to a conflict with the
  # Pop_OS! prompt's color codes.
  #
  # To fix this, we had to manually edit ~/.bashrc to:
  # 1. Define a function:
  #    show_venv_prefix() {
  #      [ -n "$VIRTUAL_ENV" ] && echo -n "(.venv) "
  #    }
  # 2. Add that function definition *before* the PS1 lines.
  # 3. Call this function from *inside* the PS1 string definitions:
  #    PS1='$(show_venv_prefix)${debian_chroot...
  # 4. We also had to change PS1's \033 color codes to \e to
  #    fix a parsing error this change introduced.
  #
  # This file's only job is to set $VIRTUAL_ENV. The .bashrc's
  # job is to see it and draw the prompt.
  export VIRTUAL_ENV="$PWD/.venv"
  # --- End .bashrc Integration ---
else
  echo "No .venv found. Create one with: python3 -m venv .venv"
fi

# Add repo's scripts folder to PATH
PATH_add scripts

# Ensure Python modules under src/ are importable
export PYTHONPATH="$PWD/src"

# Optional default for context outputs
export CONTEXT_REPORTS_DIR="$PWD/context_reports"

echo "AI_APP environment active (manual venv, scripts, PYTHONPATH set)"

# --- aicli function (works with direnv) ---
aicli() {
  python -m cli_bridge.cli "$@"
}
export -f aicli

