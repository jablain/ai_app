================================================================================
SOURCE CODE COMPILATION
================================================================================


================================================================================
FILE: README.md
================================================================================
# AI Chat UI

GTK4/libadwaita graphical interface for ai-cli-bridge.

## Features

- âœ… Native GNOME integration (GTK4 + libadwaita)
- âœ… AI-agnostic interface (works with Claude, ChatGPT, Gemini)
- âœ… Large prompt support (paste megabytes from clipboard)
- âœ… Large response handling (efficient scrolling)
- âœ… Basic markdown formatting (bold, italic, code, headers, lists)
- âœ… Copy to clipboard button
- âœ… Keyboard shortcuts (Ctrl+Enter to send)

## Requirements

### System Dependencies (already on your Pop!_OS)
- Python 3.10+
- GTK4
- libadwaita
- PyGObject

Verify installation:
```bash
python3 -c "import gi; gi.require_version('Gtk', '4.0'); gi.require_version('Adw', '1'); from gi.repository import Gtk, Adw; print('âœ“ GTK4 + libadwaita ready')"
```

### Python Dependencies
- `pygobject` (GTK bindings)
- `ai-cli-bridge` (installed separately)

## Installation

### 1. Create project directory
```bash
mkdir -p ~/projects/ai-chat-ui
cd ~/projects/ai-chat-ui
```

### 2. Create the package structure
```
ai-chat-ui/
â”œâ”€â”€ ai_chat_ui/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ window.py
â”‚   â”œâ”€â”€ response_display.py
â”‚   â””â”€â”€ markdown_parser.py
â”œâ”€â”€ pyproject.toml
â””â”€â”€ README.md
```

Copy the provided files into this structure.

### 3. Install in editable mode
```bash
# Activate ai-cli-bridge venv or create new one
source ~/.ai_cli_bridge/venv/bin/activate

# Install ai-chat-ui
pip install -e ~/projects/ai-chat-ui
```

## Usage

### 1. Start CDP browser (Claude)
```bash
# Launch browser with remote debugging
chromium --remote-debugging-port=9223 \
  --user-data-dir=~/.ai_cli_bridge/data/profiles/claude \
  https://claude.ai
```

Authenticate manually if needed.

### 2. Launch UI
```bash
ai-chat-ui
```

### 3. Using the interface

**Send a prompt:**
1. Select AI from dropdown (default: Claude)
2. Type or paste prompt in bottom text area
3. Click "Send" or press Ctrl+Enter

**Copy response:**
- Click the copy button (ðŸ“‹) below the response area

**Keyboard shortcuts:**
- `Ctrl+Enter` - Send prompt
- `Ctrl+V` - Paste into prompt area (handles large pastes)

## Architecture

### Component Overview

```
AIChatApplication (Adw.Application)
    â””â”€â”€ ChatWindow (Adw.ApplicationWindow)
        â”œâ”€â”€ HeaderBar (AI selector, status)
        â”œâ”€â”€ ResponseDisplay (formatted output + copy button)
        â”‚   â”œâ”€â”€ TextView (with TextTags)
        â”‚   â””â”€â”€ MarkdownParser (basic formatting)
        â””â”€â”€ Prompt Input (TextView + Send button)
```

### Markdown Support (Phase 1)

Supported formatting:
- `**bold**` â†’ **Bold text**
- `*italic*` â†’ *Italic text*
- `` `code` `` â†’ `Monospace inline code`
- ` ```code block``` ` â†’ Monospace block with background
- `# Header` â†’ Large bold text
- `- List item` â†’ Bulleted lists

### Integration with ai-cli-bridge

The UI imports `AIFactory` directly:
```python
from ai_cli_bridge.ai.factory import AIFactory

# Get available AIs
ai_list = AIFactory.list_available()

# Create AI instance
ai_class = AIFactory.get_class("claude")
config = ai_class.get_default_config()
ai = AIFactory.create("claude", config)

# Send prompt
success, snippet, markdown, metadata = await ai.send_prompt(message)
```

## Future Enhancements (Phase 2)

- Full markdown rendering with WebKitGTK
- Conversation history navigation
- Multiple conversation tabs
- File upload support
- Image extraction from responses
- Custom themes
- Message export

## Troubleshooting

### "ai-cli-bridge not found"
Ensure ai-cli-bridge is installed in the same venv:
```bash
pip install -e /path/to/ai-cli-bridge
```

### "Connection failed"
1. Verify CDP browser is running with `--remote-debugging-port=9223`
2. Check: `ai-cli-bridge status claude`

### UI not launching
Verify GTK4 dependencies:
```bash
python3 -c "from gi.repository import Gtk, Adw"
```

## Development

### Running from source
```bash
cd ~/projects/ai-chat-ui
python -m ai_chat_ui.main
```

### Debug mode
Add debug output to ai-cli-bridge operations:
```python
self.current_ai.set_debug(True)
```

## License

MIT (or match ai-cli-bridge license)



================================================================================
FILE: ai_chat_ui/__init__.py
================================================================================
"""
AI Chat UI - GTK4/libadwaita frontend for ai-cli-bridge
"""

__version__ = "0.1.0"

from .main import main

__all__ = ['main']



================================================================================
FILE: ai_chat_ui/main.py
================================================================================
"""
AI Chat UI - GTK4/libadwaita frontend for ai-cli-bridge
Main application entry point
"""
import sys
import gi

gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')

from gi.repository import Gtk, Adw, GLib
from .window import ChatWindow

class AIChatApplication(Adw.Application):
    """Main GTK application"""
    
    def __init__(self):
        super().__init__(
            application_id=None,
            flags=0
        )
        self.window = None
    
    def do_activate(self):
        """Called when application is activated"""
        if not self.window:
            self.window = ChatWindow(application=self)
        self.window.present()

def main():
    """Application entry point"""
    app = AIChatApplication()
    return app.run(sys.argv)

if __name__ == '__main__':
    sys.exit(main())



================================================================================
FILE: ai_chat_ui/markdown_parser.py
================================================================================
"""
Simple markdown parser that applies GTK TextTags
Supports: bold, italic, code, headers, code blocks, lists
"""
import re

class MarkdownParser:
    """Parse markdown and apply formatting to TextBuffer"""
    
    def __init__(self, text_buffer):
        self.buffer = text_buffer
    
    def parse_and_format(self, text):
        """Parse markdown text and apply formatting"""
        lines = text.split('\n')
        
        i = 0
        while i < len(lines):
            line = lines[i]
            
            # Code block (fenced with ``` or indented)
            if line.strip().startswith('```'):
                i = self._handle_code_block(lines, i)
                continue
            
            # Headers
            if line.startswith('#'):
                self._handle_header(line)
                i += 1
                continue
            
            # List items
            if re.match(r'^[\s]*[-*+]\s', line):
                self._handle_list_item(line)
                i += 1
                continue
            
            # Regular paragraph with inline formatting
            self._handle_inline_formatting(line)
            i += 1
        
    def _handle_code_block(self, lines, start_idx):
        """Handle fenced code blocks"""
        start_idx += 1  # Skip opening ```
        code_lines = []
        
        i = start_idx
        while i < len(lines):
            if lines[i].strip().startswith('```'):
                break
            code_lines.append(lines[i])
            i += 1
        
        # Insert code block
        code_text = '\n'.join(code_lines) + '\n'
        end_iter = self.buffer.get_end_iter()
        self.buffer.insert_with_tags_by_name(
            end_iter,
            code_text,
            "code-block"
        )
        
        return i + 1  # Skip closing ```
    
    def _handle_header(self, line):
        """Handle header lines"""
        match = re.match(r'^(#{1,3})\s+(.+)$', line)
        if not match:
            self._insert_text(line + '\n')
            return
        
        level = len(match.group(1))
        text = match.group(2)
        
        tag_name = f"h{level}"
        end_iter = self.buffer.get_end_iter()
        self.buffer.insert_with_tags_by_name(
            end_iter,
            text + '\n',
            tag_name
        )
    
    def _handle_list_item(self, line):
        """Handle list items"""
        # Remove bullet and clean up
        text = re.sub(r'^[\s]*[-*+]\s+', 'â€¢ ', line)
        
        end_iter = self.buffer.get_end_iter()
        self.buffer.insert_with_tags_by_name(
            end_iter,
            text + '\n',
            "list"
        )
    
    def _handle_inline_formatting(self, line):
        """Handle inline formatting (bold, italic, code)"""
        if not line.strip():
            self._insert_text('\n')
            return
        
        # Pattern matching order matters!
        # Match bold (**text**), italic (*text*), code (`text`)
        
        pos = 0
        while pos < len(line):
            # Try to match formatting patterns
            
            # Bold: **text**
            bold_match = re.match(r'\*\*(.+?)\*\*', line[pos:])
            if bold_match:
                self._insert_tagged_text(bold_match.group(1), "bold")
                pos += bold_match.end()
                continue
            
            # Code: `text`
            code_match = re.match(r'`(.+?)`', line[pos:])
            if code_match:
                self._insert_tagged_text(code_match.group(1), "code")
                pos += code_match.end()
                continue
            
            # Italic: *text* (but not ** which is bold)
            italic_match = re.match(r'\*([^*]+?)\*', line[pos:])
            if italic_match:
                self._insert_tagged_text(italic_match.group(1), "italic")
                pos += italic_match.end()
                continue
            
            # No match, insert plain character
            self._insert_text(line[pos])
            pos += 1
        
        # End of line
        self._insert_text('\n')
    
    def _insert_text(self, text):
        """Insert plain text"""
        end_iter = self.buffer.get_end_iter()
        self.buffer.insert(end_iter, text)
    
    def _insert_tagged_text(self, text, tag_name):
        """Insert text with a specific tag"""
        end_iter = self.buffer.get_end_iter()
        self.buffer.insert_with_tags_by_name(end_iter, text, tag_name)



================================================================================
FILE: ai_chat_ui/response_display.py
================================================================================
"""
Response display widget with markdown formatting support
"""
from gi.repository import Gtk, Gdk, Pango
from .markdown_parser import MarkdownParser

class ResponseDisplay:
    """TextView with markdown formatting and copy button"""
    
    def __init__(self):
        # Main container
        self.container = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        
        # Scrolled text view
        scroll = Gtk.ScrolledWindow()
        scroll.set_vexpand(True)
        scroll.set_min_content_height(200)
        
        self.text_view = Gtk.TextView()
        self.text_view.set_editable(False)
        self.text_view.set_wrap_mode(Gtk.WrapMode.WORD)
        self.text_view.set_left_margin(12)
        self.text_view.set_right_margin(12)
        self.text_view.set_top_margin(12)
        self.text_view.set_bottom_margin(12)
        
        self.buffer = self.text_view.get_buffer()
        
        # Setup text tags for formatting
        self._setup_tags()
        
        scroll.set_child(self.text_view)
        self.container.append(scroll)
        
        # Action bar with copy button
        action_bar = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        action_bar.set_margin_top(6)
        action_bar.set_margin_bottom(6)
        action_bar.set_margin_end(6)
        action_bar.set_halign(Gtk.Align.END)
        
        copy_button = Gtk.Button()
        copy_button.set_icon_name("edit-copy-symbolic")
        copy_button.set_tooltip_text("Copy response to clipboard")
        copy_button.connect("clicked", self._on_copy_clicked)
        action_bar.append(copy_button)
        
        self.container.append(action_bar)
        
        # Markdown parser
        self.parser = MarkdownParser(self.buffer)
    
    def _setup_tags(self):
        """Create TextTags for markdown formatting"""
        tag_table = self.buffer.get_tag_table()
        
        # Bold
        bold_tag = self.buffer.create_tag("bold")
        bold_tag.set_property("weight", Pango.Weight.BOLD)
        
        # Italic
        italic_tag = self.buffer.create_tag("italic")
        italic_tag.set_property("style", Pango.Style.ITALIC)
        
        # Inline code
        code_tag = self.buffer.create_tag("code")
        code_tag.set_property("family", "monospace")
        code_tag.set_property("background", "#f0f0f0")
        code_tag.set_property("foreground", "#333333")
        
        # Code block
        code_block_tag = self.buffer.create_tag("code-block")
        code_block_tag.set_property("family", "monospace")
        code_block_tag.set_property("background", "#f5f5f5")
        code_block_tag.set_property("left-margin", 20)
        code_block_tag.set_property("right-margin", 20)
        code_block_tag.set_property("pixels-above-lines", 4)
        code_block_tag.set_property("pixels-below-lines", 4)
        
        # Header 1
        h1_tag = self.buffer.create_tag("h1")
        h1_tag.set_property("weight", Pango.Weight.BOLD)
        h1_tag.set_property("scale", 1.5)
        h1_tag.set_property("pixels-above-lines", 10)
        h1_tag.set_property("pixels-below-lines", 5)
        
        # Header 2
        h2_tag = self.buffer.create_tag("h2")
        h2_tag.set_property("weight", Pango.Weight.BOLD)
        h2_tag.set_property("scale", 1.3)
        h2_tag.set_property("pixels-above-lines", 8)
        h2_tag.set_property("pixels-below-lines", 4)
        
        # Header 3
        h3_tag = self.buffer.create_tag("h3")
        h3_tag.set_property("weight", Pango.Weight.BOLD)
        h3_tag.set_property("scale", 1.1)
        h3_tag.set_property("pixels-above-lines", 6)
        h3_tag.set_property("pixels-below-lines", 3)
        
        # List item
        list_tag = self.buffer.create_tag("list")
        list_tag.set_property("left-margin", 20)
    
    def set_text(self, text):
        """Set and format text content"""
        self.buffer.set_text("")  # Clear existing
        self.parser.parse_and_format(text)
    
    def get_text(self):
        """Get plain text content"""
        start = self.buffer.get_start_iter()
        end = self.buffer.get_end_iter()
        return self.buffer.get_text(start, end, False)
    
    def get_widget(self):
        """Get the container widget"""
        return self.container
    
    def _on_copy_clicked(self, button):
        """Copy response text to clipboard"""
        text = self.get_text()
        if text:
            clipboard = Gdk.Display.get_default().get_clipboard()
            clipboard.set(text)



================================================================================
FILE: ai_chat_ui/window.py
================================================================================
"""
Main chat window with prompt input and response display
Fixed for libadwaita 1.0 compatibility (GNOME 42) and proper async handling
Includes automatic CDP browser launch
"""
import asyncio
import threading
import subprocess
import time
from pathlib import Path
from gi.repository import Gtk, Adw, GLib, Gdk

# Import ai-cli-bridge components
try:
    from ai_cli_bridge.ai.factory import AIFactory
except ImportError:
    print("Warning: ai-cli-bridge not found. Install with: pip install -e /path/to/ai-cli-bridge")
    AIFactory = None

from .response_display import ResponseDisplay

class ChatWindow(Adw.ApplicationWindow):
    """Main application window"""
    
    def __init__(self, **kwargs):
        print("ChatWindow.__init__ called")  # ADD THIS LINE
        super().__init__(**kwargs)
     
        # Window properties
        self.set_title("AI Chat")
        self.set_default_size(800, 600)
    
        # Current AI instance
        self.current_ai = None
        self.ai_name = "claude"  # Default
    
        # Track if we launched CDP (so we know whether to close it)
        self.cdp_launched_by_us = False
    
        # Build UI
        self._build_ui()
    
        # Connect close signal
        self.connect("close-request", self._on_window_close)
    
        # Connect realize signal - called when window fully shown
        self.connect("realize", lambda w: GLib.idle_add(self._check_cdp_and_init))
        
    def _build_ui(self):
        """Construct the UI hierarchy"""
        
        # Main container
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        
        # Header bar
        header = Adw.HeaderBar()
        
        # AI selector in header
        self.ai_selector = Gtk.DropDown()
        if AIFactory:
            ai_list = AIFactory.list_available()
            string_list = Gtk.StringList()
            for ai in ai_list:
                string_list.append(ai)
            self.ai_selector.set_model(string_list)
            self.ai_selector.connect("notify::selected", self._on_ai_changed)
        header.pack_start(self.ai_selector)
        
        # Status label
        self.status_label = Gtk.Label(label="Ready")
        self.status_label.add_css_class("dim-label")
        header.pack_end(self.status_label)
        
        # Add header to main box
        main_box.append(header)
        
        # Content area - split into response and input
        content_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        content_box.set_margin_top(12)
        content_box.set_margin_bottom(12)
        content_box.set_margin_start(12)
        content_box.set_margin_end(12)
        
        # Response display area
        response_frame = Gtk.Frame()
        self.response_display = ResponseDisplay()
        response_frame.set_child(self.response_display.get_widget())
        content_box.append(response_frame)
        
        # Separator
        separator = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
        content_box.append(separator)
        
        # Prompt input area
        input_frame = Gtk.Frame()
        input_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        
        # Prompt text view
        prompt_scroll = Gtk.ScrolledWindow()
        prompt_scroll.set_min_content_height(100)
        prompt_scroll.set_vexpand(False)
        
        self.prompt_view = Gtk.TextView()
        self.prompt_view.set_wrap_mode(Gtk.WrapMode.WORD)
        self.prompt_view.set_left_margin(6)
        self.prompt_view.set_right_margin(6)
        self.prompt_view.set_top_margin(6)
        self.prompt_view.set_bottom_margin(6)
        
        # Enable Ctrl+Enter to send
        controller = Gtk.EventControllerKey()
        controller.connect("key-pressed", self._on_key_pressed)
        self.prompt_view.add_controller(controller)
        
        prompt_scroll.set_child(self.prompt_view)
        input_box.append(prompt_scroll)
        
        # Send button
        button_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        button_box.set_halign(Gtk.Align.END)
        button_box.set_margin_top(6)
        button_box.set_margin_bottom(6)
        button_box.set_margin_end(6)
        
        self.send_button = Gtk.Button(label="Send")
        self.send_button.add_css_class("suggested-action")
        self.send_button.connect("clicked", self._on_send_clicked)
        button_box.append(self.send_button)
        
        input_box.append(button_box)
        input_frame.set_child(input_box)
        content_box.append(input_frame)
        
        # Set proportions (response gets 60%, input gets 40%)
        response_frame.set_vexpand(True)
        input_frame.set_vexpand(False)
        
        main_box.append(content_box)
        
        self.set_content(main_box)
    
    def _init_ai(self):
        """Initialize the AI instance"""
        if not AIFactory:
            self._set_status("Error: ai-cli-bridge not available")
            return
        
        try:
            ai_class = AIFactory.get_class(self.ai_name)
            config = ai_class.get_default_config()
            self.current_ai = AIFactory.create(self.ai_name, config)
            self._set_status(f"Ready - {self.ai_name}")
        except Exception as e:
            self._set_status(f"Error: {e}")
    
    def _on_ai_changed(self, dropdown, _):
        """Handle AI selection change"""
        selected = dropdown.get_selected()
        if AIFactory:
            ai_list = AIFactory.list_available()
            if selected < len(ai_list):
                self.ai_name = ai_list[selected]
                self._init_ai()
    
    def _on_key_pressed(self, controller, keyval, keycode, state):
        """Handle keyboard shortcuts"""
        # Ctrl+Enter to send
        if (keyval == Gdk.KEY_Return and 
            state & Gdk.ModifierType.CONTROL_MASK):
            self._on_send_clicked(None)
            return True
        return False
    
    def _on_send_clicked(self, button):
        """Handle send button click"""
        # Get prompt text
        buffer = self.prompt_view.get_buffer()
        start = buffer.get_start_iter()
        end = buffer.get_end_iter()
        prompt = buffer.get_text(start, end, False).strip()
        
        if not prompt:
            return
        
        if not self.current_ai:
            self._set_status("Error: No AI initialized")
            return
        
        # Disable send button during processing
        self.send_button.set_sensitive(False)
        self._set_status("Sending...")
        
        # Run async operation in a thread to avoid blocking GTK
        thread = threading.Thread(target=self._send_prompt_thread, args=(prompt,))
        thread.daemon = True
        thread.start()
    
    def _send_prompt_thread(self, prompt):
        """Thread function to run async prompt sending"""
        # Create new event loop for this thread
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        try:
            # Run the async operation
            loop.run_until_complete(self._send_prompt_async(prompt))
        finally:
            loop.close()
    
    async def _send_prompt_async(self, prompt):
        """Send prompt to AI and display response"""
        try:
            # Call ai-cli-bridge
            success, snippet, markdown, metadata = await self.current_ai.send_prompt(
                prompt,
                wait_for_response=True,
                timeout_s=120
            )
            
            if success:
                # Display response (use GLib.idle_add for thread safety)
                GLib.idle_add(self._display_response, markdown or snippet)
                elapsed = metadata.get('elapsed_ms', 0)
                GLib.idle_add(self._set_status, f"Complete ({elapsed}ms)")
            else:
                GLib.idle_add(self._set_status, "Error: Send failed")
                
        except Exception as e:
            GLib.idle_add(self._set_status, f"Error: {e}")
        
        finally:
            # Re-enable send button
            GLib.idle_add(self.send_button.set_sensitive, True)
    
    def _display_response(self, text):
        """Display AI response"""
        self.response_display.set_text(text)
        return False  # Don't repeat this idle callback
    
    def _set_status(self, text):
        """Update status label"""
        self.status_label.set_label(text)
        return False  # Don't repeat this idle callback
    
    def _close_cdp_browser(self):
        """Close CDP browser gracefully"""
        import urllib.request
        import json
        
        try:
            # Get list of browser targets
            response = urllib.request.urlopen('http://127.0.0.1:9223/json', timeout=2)
            targets = json.loads(response.read().decode())
            
            # Find the browser target and close it
            for target in targets:
                if target.get('type') == 'page':
                    target_id = target.get('id')
                    close_url = f"http://127.0.0.1:9223/json/close/{target_id}"
                    try:
                        urllib.request.urlopen(close_url, timeout=1)
                    except:
                        pass
            
            # Give browser time to close gracefully
            time.sleep(0.5)
            
        except Exception as e:
            print(f"Note: Could not close CDP browser gracefully: {e}")
    
    def _on_window_close(self, window):
        """Handle window close event"""
        if self.cdp_launched_by_us and self._check_cdp_running():
            # We launched CDP, so close it
            thread = threading.Thread(target=self._close_cdp_browser)
            thread.daemon = True
            thread.start()
            
            # Small delay to allow closing
            time.sleep(0.3)
        
        return False  # Allow window to close
    
    def _check_cdp_running(self):
        """Check if CDP is accessible on port 9223"""
        import urllib.request
        try:
            urllib.request.urlopen('http://127.0.0.1:9223/json', timeout=1)
            return True
        except:
            return False
    
    def _launch_cdp_browser(self):
        """Attempt to launch CDP browser using launch_cdp.sh"""
        # Find launch script
        script_paths = [
            Path.home() / "dev/ai_app/shared/scripts/launch_cdp.sh",
            Path.home() / "dev/ai_app/launch_cdp.sh",
        ]
        
        launch_script = None
        for path in script_paths:
            if path.exists():
                launch_script = path
                break
        
        if not launch_script:
            return False, "launch_cdp.sh not found"
        
        try:
            # Launch script in background
            subprocess.Popen(
                [str(launch_script)],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                start_new_session=True
            )
            
            # Wait up to 15 seconds for CDP to become available
            for i in range(15):
                time.sleep(1)
                if self._check_cdp_running():
                    return True, "CDP browser launched successfully"
            
            return False, "CDP browser launched but not responding"
            
        except Exception as e:
            return False, f"Failed to launch: {e}"
    
    def _check_cdp_and_init(self):
        """Check CDP status and launch if needed, then initialize AI"""
        print("_check_cdp_and_init CALLED")  # ADD THIS LINE
        self._set_status("Checking CDP browser...")
        
        if self._check_cdp_running():
            # CDP already running (not launched by us)
            self._set_status("CDP browser connected")
            self.cdp_launched_by_us = False
            self._init_ai()
            return False
        
        # CDP not running, try to launch
        self._set_status("CDP browser not running, launching...")
        self.cdp_launched_by_us = True  # Mark that we launched it
        
        # Run launch in thread to avoid blocking UI
        thread = threading.Thread(target=self._launch_cdp_thread)
        thread.daemon = True
        thread.start()
        
        return False
    
    def _launch_cdp_thread(self):
        """Thread function to launch CDP"""
        success, message = self._launch_cdp_browser()
        
        if success:
            GLib.idle_add(self._set_status, "CDP browser ready")
            GLib.idle_add(self._init_ai)
        else:
            GLib.idle_add(self._show_cdp_error, message)
    
    def _show_cdp_error(self, message):
        """Show error dialog for CDP failure"""
        dialog = Adw.MessageDialog.new(
            self,
            "CDP Browser Not Available",
            message
        )
        dialog.add_response("ok", "OK")
        dialog.set_default_response("ok")
        dialog.set_close_response("ok")
        
        # Add details
        dialog.set_body(
            f"{message}\n\n"
            "Please launch the CDP browser manually:\n"
            "~/dev/ai_app/shared/scripts/launch_cdp.sh"
        )
        
        dialog.present()
        self._set_status("Error: CDP browser not available")
        return False



================================================================================
FILE: pyproject.toml
================================================================================
[build-system]
requires = ["setuptools>=45", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "ai-chat-ui"
version = "0.1.0"
description = "GTK4/libadwaita UI for ai-cli-bridge"
readme = "README.md"
requires-python = ">=3.10"
authors = [
    {name = "Jacques", email = "your.email@example.com"}
]
dependencies = [
    # PyGObject is installed via system package manager (python3-gi)
    # No pip dependencies needed
]

[project.optional-dependencies]
dev = [
    "ai-cli-bridge",
]

[project.scripts]
ai-chat-ui = "ai_chat_ui.main:main"

[tool.setuptools.packages.find]
where = ["."]
include = ["ai_chat_ui*"]



================================================================================
FILE: src.txt
================================================================================
================================================================================
SOURCE CODE COMPILATION
================================================================================


================================================================================
FILE: README.md
================================================================================
# AI Chat UI

GTK4/libadwaita graphical interface for ai-cli-bridge.

## Features

- âœ… Native GNOME integration (GTK4 + libadwaita)
- âœ… AI-agnostic interface (works with Claude, ChatGPT, Gemini)
- âœ… Large prompt support (paste megabytes from clipboard)
- âœ… Large response handling (efficient scrolling)
- âœ… Basic markdown formatting (bold, italic, code, headers, lists)
- âœ… Copy to clipboard button
- âœ… Keyboard shortcuts (Ctrl+Enter to send)

## Requirements

### System Dependencies (already on your Pop!_OS)
- Python 3.10+
- GTK4
- libadwaita
- PyGObject

Verify installation:
```bash
python3 -c "import gi; gi.require_version('Gtk', '4.0'); gi.require_version('Adw', '1'); from gi.repository import Gtk, Adw; print('âœ“ GTK4 + libadwaita ready')"
```

### Python Dependencies
- `pygobject` (GTK bindings)
- `ai-cli-bridge` (installed separately)

## Installation

### 1. Create project directory
```bash
mkdir -p ~/projects/ai-chat-ui
cd ~/projects/ai-chat-ui
```

### 2. Create the package structure
```
ai-chat-ui/
â”œâ”€â”€ ai_chat_ui/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ window.py
â”‚   â”œâ”€â”€ response_display.py
â”‚   â””â”€â”€ markdown_parser.py
â”œâ”€â”€ pyproject.toml
â””â”€â”€ README.md
```

Copy the provided files into this structure.

### 3. Install in editable mode
```bash
# Activate ai-cli-bridge venv or create new one
source ~/.ai_cli_bridge/venv/bin/activate

# Install ai-chat-ui
pip install -e ~/projects/ai-chat-ui
```

## Usage

### 1. Start CDP browser (Claude)
```bash
# Launch browser with remote debugging
chromium --remote-debugging-port=9223 \
  --user-data-dir=~/.ai_cli_bridge/data/profiles/claude \
  https://claude.ai
```

Authenticate manually if needed.

### 2. Launch UI
```bash
ai-chat-ui
```

### 3. Using the interface

**Send a prompt:**
1. Select AI from dropdown (default: Claude)
2. Type or paste prompt in bottom text area
3. Click "Send" or press Ctrl+Enter

**Copy response:**
- Click the copy button (ðŸ“‹) below the response area

**Keyboard shortcuts:**
- `Ctrl+Enter` - Send prompt
- `Ctrl+V` - Paste into prompt area (handles large pastes)

## Architecture

### Component Overview

```
AIChatApplication (Adw.Application)
    â””â”€â”€ ChatWindow (Adw.ApplicationWindow)
        â”œâ”€â”€ HeaderBar (AI selector, status)
        â”œâ”€â”€ ResponseDisplay (formatted output + copy button)
        â”‚   â”œâ”€â”€ TextView (with TextTags)
        â”‚   â””â”€â”€ MarkdownParser (basic formatting)
        â””â”€â”€ Prompt Input (TextView + Send button)
```

### Markdown Support (Phase 1)

Supported formatting:
- `**bold**` â†’ **Bold text**
- `*italic*` â†’ *Italic text*
- `` `code` `` â†’ `Monospace inline code`
- ` ```code block``` ` â†’ Monospace block with background
- `# Header` â†’ Large bold text
- `- List item` â†’ Bulleted lists

### Integration with ai-cli-bridge

The UI imports `AIFactory` directly:
```python
from ai_cli_bridge.ai.factory import AIFactory

# Get available AIs
ai_list = AIFactory.list_available()

# Create AI instance
ai_class = AIFactory.get_class("claude")
config = ai_class.get_default_config()
ai = AIFactory.create("claude", config)

# Send prompt
success, snippet, markdown, metadata = await ai.send_prompt(message)
```

## Future Enhancements (Phase 2)

- Full markdown rendering with WebKitGTK
- Conversation history navigation
- Multiple conversation tabs
- File upload support
- Image extraction from responses
- Custom themes
- Message export

## Troubleshooting

### "ai-cli-bridge not found"
Ensure ai-cli-bridge is installed in the same venv:
```bash
pip install -e /path/to/ai-cli-bridge
```

### "Connection failed"
1. Verify CDP browser is running with `--remote-debugging-port=9223`
2. Check: `ai-cli-bridge status claude`

### UI not launching
Verify GTK4 dependencies:
```bash
python3 -c "from gi.repository import Gtk, Adw"
```

## Development

### Running from source
```bash
cd ~/projects/ai-chat-ui
python -m ai_chat_ui.main
```

### Debug mode
Add debug output to ai-cli-bridge operations:
```python
self.current_ai.set_debug(True)
```

## License

MIT (or match ai-cli-bridge license)



================================================================================
FILE: ai_chat_ui/__init__.py
================================================================================
"""
AI Chat UI - GTK4/libadwaita frontend for ai-cli-bridge
"""

__version__ = "0.1.0"

from .main import main

__all__ = ['main']



================================================================================
FILE: ai_chat_ui/main.py
================================================================================
"""
AI Chat UI - GTK4/libadwaita frontend for ai-cli-bridge
Main application entry point
"""
import sys
import gi

gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')

from gi.repository import Gtk, Adw, GLib
from .window import ChatWindow

class AIChatApplication(Adw.Application):
    """Main GTK application"""
    
    def __init__(self):
        super().__init__(
            application_id=None,
            flags=0
        )
        self.window = None
    
    def do_activate(self):
        """Called when application is activated"""
        if not self.window:
            self.window = ChatWindow(application=self)
        self.window.present()

def main():
    """Application entry point"""
    app = AIChatApplication()
    return app.run(sys.argv)

if __name__ == '__main__':
    sys.exit(main())



================================================================================
FILE: ai_chat_ui/markdown_parser.py
================================================================================
"""
Simple markdown parser that applies GTK TextTags
Supports: bold, italic, code, headers, code blocks, lists
"""
import re

class MarkdownParser:
    """Parse markdown and apply formatting to TextBuffer"""
    
    def __init__(self, text_buffer):
        self.buffer = text_buffer
    
    def parse_and_format(self, text):
        """Parse markdown text and apply formatting"""
        lines = text.split('\n')
        
        i = 0
        while i < len(lines):
            line = lines[i]
            
            # Code block (fenced with ``` or indented)
            if line.strip().startswith('```'):
                i = self._handle_code_block(lines, i)
                continue
            
            # Headers
            if line.startswith('#'):
                self._handle_header(line)
                i += 1
                continue
            
            # List items
            if re.match(r'^[\s]*[-*+]\s', line):
                self._handle_list_item(line)
                i += 1
                continue
            
            # Regular paragraph with inline formatting
            self._handle_inline_formatting(line)
            i += 1
        
    def _handle_code_block(self, lines, start_idx):
        """Handle fenced code blocks"""
        start_idx += 1  # Skip opening ```
        code_lines = []
        
        i = start_idx
        while i < len(lines):
            if lines[i].strip().startswith('```'):
                break
            code_lines.append(lines[i])
            i += 1
        
        # Insert code block
        code_text = '\n'.join(code_lines) + '\n'
        end_iter = self.buffer.get_end_iter()
        self.buffer.insert_with_tags_by_name(
            end_iter,
            code_text,
            "code-block"
        )
        
        return i + 1  # Skip closing ```
    
    def _handle_header(self, line):
        """Handle header lines"""
        match = re.match(r'^(#{1,3})\s+(.+)$', line)
        if not match:
            self._insert_text(line + '\n')
            return
        
        level = len(match.group(1))
        text = match.group(2)
        
        tag_name = f"h{level}"
        end_iter = self.buffer.get_end_iter()
        self.buffer.insert_with_tags_by_name(
            end_iter,
            text + '\n',
            tag_name
        )
    
    def _handle_list_item(self, line):
        """Handle list items"""
        # Remove bullet and clean up
        text = re.sub(r'^[\s]*[-*+]\s+', 'â€¢ ', line)
        
        end_iter = self.buffer.get_end_iter()
        self.buffer.insert_with_tags_by_name(
            end_iter,
            text + '\n',
            "list"
        )
    
    def _handle_inline_formatting(self, line):
        """Handle inline formatting (bold, italic, code)"""
        if not line.strip():
            self._insert_text('\n')
            return
        
        # Pattern matching order matters!
        # Match bold (**text**), italic (*text*), code (`text`)
        
        pos = 0
        while pos < len(line):
            # Try to match formatting patterns
            
            # Bold: **text**
            bold_match = re.match(r'\*\*(.+?)\*\*', line[pos:])
            if bold_match:
                self._insert_tagged_text(bold_match.group(1), "bold")
                pos += bold_match.end()
                continue
            
            # Code: `text`
            code_match = re.match(r'`(.+?)`', line[pos:])
            if code_match:
                self._insert_tagged_text(code_match.group(1), "code")
                pos += code_match.end()
                continue
            
            # Italic: *text* (but not ** which is bold)
            italic_match = re.match(r'\*([^*]+?)\*', line[pos:])
            if italic_match:
                self._insert_tagged_text(italic_match.group(1), "italic")
                pos += italic_match.end()
                continue
            
            # No match, insert plain character
            self._insert_text(line[pos])
            pos += 1
        
        # End of line
        self._insert_text('\n')
    
    def _insert_text(self, text):
        """Insert plain text"""
        end_iter = self.buffer.get_end_iter()
        self.buffer.insert(end_iter, text)
    
    def _insert_tagged_text(self, text, tag_name):
        """Insert text with a specific tag"""
        end_iter = self.buffer.get_end_iter()
        self.buffer.insert_with_tags_by_name(end_iter, text, tag_name)



================================================================================
FILE: ai_chat_ui/response_display.py
================================================================================
"""
Response display widget with markdown formatting support
"""
from gi.repository import Gtk, Gdk, Pango
from .markdown_parser import MarkdownParser

class ResponseDisplay:
    """TextView with markdown formatting and copy button"""
    
    def __init__(self):
        # Main container
        self.container = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        
        # Scrolled text view
        scroll = Gtk.ScrolledWindow()
        scroll.set_vexpand(True)
        scroll.set_min_content_height(200)
        
        self.text_view = Gtk.TextView()
        self.text_view.set_editable(False)
        self.text_view.set_wrap_mode(Gtk.WrapMode.WORD)
        self.text_view.set_left_margin(12)
        self.text_view.set_right_margin(12)
        self.text_view.set_top_margin(12)
        self.text_view.set_bottom_margin(12)
        
        self.buffer = self.text_view.get_buffer()
        
        # Setup text tags for formatting
        self._setup_tags()
        
        scroll.set_child(self.text_view)
        self.container.append(scroll)
        
        # Action bar with copy button
        action_bar = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        action_bar.set_margin_top(6)
        action_bar.set_margin_bottom(6)
        action_bar.set_margin_end(6)
        action_bar.set_halign(Gtk.Align.END)
        
        copy_button = Gtk.Button()
        copy_button.set_icon_name("edit-copy-symbolic")
        copy_button.set_tooltip_text("Copy response to clipboard")
        copy_button.connect("clicked", self._on_copy_clicked)
        action_bar.append(copy_button)
        
        self.container.append(action_bar)
        
        # Markdown parser
        self.parser = MarkdownParser(self.buffer)
    
    def _setup_tags(self):
        """Create TextTags for markdown formatting"""
        tag_table = self.buffer.get_tag_table()
        
        # Bold
        bold_tag = self.buffer.create_tag("bold")
        bold_tag.set_property("weight", Pango.Weight.BOLD)
        
        # Italic
        italic_tag = self.buffer.create_tag("italic")
        italic_tag.set_property("style", Pango.Style.ITALIC)
        
        # Inline code
        code_tag = self.buffer.create_tag("code")
        code_tag.set_property("family", "monospace")
        code_tag.set_property("background", "#f0f0f0")
        code_tag.set_property("foreground", "#333333")
        
        # Code block
        code_block_tag = self.buffer.create_tag("code-block")
        code_block_tag.set_property("family", "monospace")
        code_block_tag.set_property("background", "#f5f5f5")
        code_block_tag.set_property("left-margin", 20)
        code_block_tag.set_property("right-margin", 20)
        code_block_tag.set_property("pixels-above-lines", 4)
        code_block_tag.set_property("pixels-below-lines", 4)
        
        # Header 1
        h1_tag = self.buffer.create_tag("h1")
        h1_tag.set_property("weight", Pango.Weight.BOLD)
        h1_tag.set_property("scale", 1.5)
        h1_tag.set_property("pixels-above-lines", 10)
        h1_tag.set_property("pixels-below-lines", 5)
        
        # Header 2
        h2_tag = self.buffer.create_tag("h2")
        h2_tag.set_property("weight", Pango.Weight.BOLD)
        h2_tag.set_property("scale", 1.3)
        h2_tag.set_property("pixels-above-lines", 8)
        h2_tag.set_property("pixels-below-lines", 4)
        
        # Header 3
        h3_tag = self.buffer.create_tag("h3")
        h3_tag.set_property("weight", Pango.Weight.BOLD)
        h3_tag.set_property("scale", 1.1)
        h3_tag.set_property("pixels-above-lines", 6)
        h3_tag.set_property("pixels-below-lines", 3)
        
        # List item
        list_tag = self.buffer.create_tag("list")
        list_tag.set_property("left-margin", 20)
    
    def set_text(self, text):
        """Set and format text content"""
        self.buffer.set_text("")  # Clear existing
        self.parser.parse_and_format(text)
    
    def get_text(self):
        """Get plain text content"""
        start = self.buffer.get_start_iter()
        end = self.buffer.get_end_iter()
        return self.buffer.get_text(start, end, False)
    
    def get_widget(self):
        """Get the container widget"""
        return self.container
    
    def _on_copy_clicked(self, button):
        """Copy response text to clipboard"""
        text = self.get_text()
        if text:
            clipboard = Gdk.Display.get_default().get_clipboard()
            clipboard.set(text)



================================================================================
FILE: ai_chat_ui/window.py
================================================================================
"""
Main chat window with prompt input and response display
Fixed for libadwaita 1.0 compatibility (GNOME 42) and proper async handling
Includes automatic CDP browser launch
"""
import asyncio
import threading
import subprocess
import time
from pathlib import Path
from gi.repository import Gtk, Adw, GLib, Gdk

# Import ai-cli-bridge components
try:
    from ai_cli_bridge.ai.factory import AIFactory
except ImportError:
    print("Warning: ai-cli-bridge not found. Install with: pip install -e /path/to/ai-cli-bridge")
    AIFactory = None

from .response_display import ResponseDisplay

class ChatWindow(Adw.ApplicationWindow):
    """Main application window"""
    
    def __init__(self, **kwargs):
        print("ChatWindow.__init__ called")  # ADD THIS LINE
        super().__init__(**kwargs)
     
        # Window properties
        self.set_title("AI Chat")
        self.set_default_size(800, 600)
    
        # Current AI instance
        self.current_ai = None
        self.ai_name = "claude"  # Default
    
        # Track if we launched CDP (so we know whether to close it)
        self.cdp_launched_by_us = False
    
        # Build UI
        self._build_ui()
    
        # Connect close signal
        self.connect("close-request", self._on_window_close)
    
        # Connect realize signal - called when window fully shown
        self.connect("realize", lambda w: GLib.idle_add(self._check_cdp_and_init))
        
    def _build_ui(self):
        """Construct the UI hierarchy"""
        
        # Main container
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        
        # Header bar
        header = Adw.HeaderBar()
        
        # AI selector in header
        self.ai_selector = Gtk.DropDown()
        if AIFactory:
            ai_list = AIFactory.list_available()
            string_list = Gtk.StringList()
            for ai in ai_list:
                string_list.append(ai)
            self.ai_selector.set_model(string_list)
            self.ai_selector.connect("notify::selected", self._on_ai_changed)
        header.pack_start(self.ai_selector)
        
        # Status label
        self.status_label = Gtk.Label(label="Ready")
        self.status_label.add_css_class("dim-label")
        header.pack_end(self.status_label)
        
        # Add header to main box
        main_box.append(header)
        
        # Content area - split into response and input
        content_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        content_box.set_margin_top(12)
        content_box.set_margin_bottom(12)
        content_box.set_margin_start(12)
        content_box.set_margin_end(12)
        
        # Response display area
        response_frame = Gtk.Frame()
        self.response_display = ResponseDisplay()
        response_frame.set_child(self.response_display.get_widget())
        content_box.append(response_frame)
        
        # Separator
        separator = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
        content_box.append(separator)
        
        # Prompt input area
        input_frame = Gtk.Frame()
        input_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        
        # Prompt text view
        prompt_scroll = Gtk.ScrolledWindow()
        prompt_scroll.set_min_content_height(100)
        prompt_scroll.set_vexpand(False)
        
        self.prompt_view = Gtk.TextView()
        self.prompt_view.set_wrap_mode(Gtk.WrapMode.WORD)
        self.prompt_view.set_left_margin(6)
        self.prompt_view.set_right_margin(6)
        self.prompt_view.set_top_margin(6)
        self.prompt_view.set_bottom_margin(6)
        
        # Enable Ctrl+Enter to send
        controller = Gtk.EventControllerKey()
        controller.connect("key-pressed", self._on_key_pressed)
        self.prompt_view.add_controller(controller)
        
        prompt_scroll.set_child(self.prompt_view)
        input_box.append(prompt_scroll)
        
        # Send button
        button_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        button_box.set_halign(Gtk.Align.END)
        button_box.set_margin_top(6)
        button_box.set_margin_bottom(6)
        button_box.set_margin_end(6)
        
        self.send_button = Gtk.Button(label="Send")
        self.send_button.add_css_class("suggested-action")
        self.send_button.connect("clicked", self._on_send_clicked)
        button_box.append(self.send_button)
        
        input_box.append(button_box)
        input_frame.set_child(input_box)
        content_box.append(input_frame)
        
        # Set proportions (response gets 60%, input gets 40%)
        response_frame.set_vexpand(True)
        input_frame.set_vexpand(False)
        
        main_box.append(content_box)
        
        self.set_content(main_box)
    
    def _init_ai(self):
        """Initialize the AI instance"""
        if not AIFactory:
            self._set_status("Error: ai-cli-bridge not available")
            return
        
        try:
            ai_class = AIFactory.get_class(self.ai_name)
            config = ai_class.get_default_config()
            self.current_ai = AIFactory.create(self.ai_name, config)
            self._set_status(f"Ready - {self.ai_name}")
        except Exception as e:
            self._set_status(f"Error: {e}")
    
    def _on_ai_changed(self, dropdown, _):
        """Handle AI selection change"""
        selected = dropdown.get_selected()
        if AIFactory:
            ai_list = AIFactory.list_available()
            if selected < len(ai_list):
                self.ai_name = ai_list[selected]
                self._init_ai()
    
    def _on_key_pressed(self, controller, keyval, keycode, state):
        """Handle keyboard shortcuts"""
        # Ctrl+Enter to send
        if (keyval == Gdk.KEY_Return and 
            state & Gdk.ModifierType.CONTROL_MASK):
            self._on_send_clicked(None)
            return True
        return False
    
    def _on_send_clicked(self, button):
        """Handle send button click"""
        # Get prompt text
        buffer = self.prompt_view.get_buffer()
        start = buffer.get_start_iter()
        end = buffer.get_end_iter()
        prompt = buffer.get_text(start, end, False).strip()
        
        if not prompt:
            return
        
        if not self.current_ai:
            self._set_status("Error: No AI initialized")
            return
        
        # Disable send button during processing
        self.send_button.set_sensitive(False)
        self._set_status("Sending...")
        
        # Run async operation in a thread to avoid blocking GTK
        thread = threading.Thread(target=self._send_prompt_thread, args=(prompt,))
        thread.daemon = True
        thread.start()
    
    def _send_prompt_thread(self, prompt):
        """Thread function to run async prompt sending"""
        # Create new event loop for this thread
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        try:
            # Run the async operation
            loop.run_until_complete(self._send_prompt_async(prompt))
        finally:
            loop.close()
    
    async def _send_prompt_async(self, prompt):
        """Send prompt to AI and display response"""
        try:
            # Call ai-cli-bridge
            success, snippet, markdown, metadata = await self.current_ai.send_prompt(
                prompt,
                wait_for_response=True,
                timeout_s=120
            )
            
            if success:
                # Display response (use GLib.idle_add for thread safety)
                GLib.idle_add(self._display_response, markdown or snippet)
                elapsed = metadata.get('elapsed_ms', 0)
                GLib.idle_add(self._set_status, f"Complete ({elapsed}ms)")
            else:
                GLib.idle_add(self._set_status, "Error: Send failed")
                
        except Exception as e:
            GLib.idle_add(self._set_status, f"Error: {e}")
        
        finally:
            # Re-enable send button
            GLib.idle_add(self.send_button.set_sensitive, True)
    
    def _display_response(self, text):
        """Display AI response"""
        self.response_display.set_text(text)
        return False  # Don't repeat this idle callback
    
    def _set_status(self, text):
        """Update status label"""
        self.status_label.set_label(text)
        return False  # Don't repeat this idle callback
    
    def _close_cdp_browser(self):
        """Close CDP browser gracefully"""
        import urllib.request
        import json
        
        try:
            # Get list of browser targets
            response = urllib.request.urlopen('http://127.0.0.1:9223/json', timeout=2)
            targets = json.loads(response.read().decode())
            
            # Find the browser target and close it
            for target in targets:
                if target.get('type') == 'page':
                    target_id = target.get('id')
                    close_url = f"http://127.0.0.1:9223/json/close/{target_id}"
                    try:
                        urllib.request.urlopen(close_url, timeout=1)
                    except:
                        pass
            
            # Give browser time to close gracefully
            time.sleep(0.5)
            
        except Exception as e:
            print(f"Note: Could not close CDP browser gracefully: {e}")
    
    def _on_window_close(self, window):
        """Handle window close event"""
        if self.cdp_launched_by_us and self._check_cdp_running():
            # We launched CDP, so close it
            thread = threading.Thread(target=self._close_cdp_browser)
            thread.daemon = True
            thread.start()
            
            # Small delay to allow closing
            time.sleep(0.3)
        
        return False  # Allow window to close
    
    def _check_cdp_running(self):
        """Check if CDP is accessible on port 9223"""
        import urllib.request
        try:
            urllib.request.urlopen('http://127.0.0.1:9223/json', timeout=1)
            return True
        except:
            return False
    
    def _launch_cdp_browser(self):
        """Attempt to launch CDP browser using launch_cdp.sh"""
        # Find launch script
        script_paths = [
            Path.home() / "dev/ai_app/shared/scripts/launch_cdp.sh",
            Path.home() / "dev/ai_app/launch_cdp.sh",
        ]
        
        launch_script = None
        for path in script_paths:
            if path.exists():
                launch_script = path
                break
        
        if not launch_script:
            return False, "launch_cdp.sh not found"
        
        try:
            # Launch script in background
            subprocess.Popen(
                [str(launch_script)],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                start_new_session=True
            )
            
            # Wait up to 15 seconds for CDP to become available
            for i in range(15):
                time.sleep(1)
                if self._check_cdp_running():
                    return True, "CDP browser launched successfully"
            
            return False, "CDP browser launched but not responding"
            
        except Exception as e:
            return False, f"Failed to launch: {e}"
    
    def _check_cdp_and_init(self):
        """Check CDP status and launch if needed, then initialize AI"""
        print("_check_cdp_and_init CALLED")  # ADD THIS LINE
        self._set_status("Checking CDP browser...")
        
        if self._check_cdp_running():
            # CDP already running (not launched by us)
            self._set_status("CDP browser connected")
            self.cdp_launched_by_us = False
            self._init_ai()
            return False
        
        # CDP not running, try to launch
        self._set_status("CDP browser not running, launching...")
        self.cdp_launched_by_us = True  # Mark that we launched it
        
        # Run launch in thread to avoid blocking UI
        thread = threading.Thread(target=self._launch_cdp_thread)
        thread.daemon = True
        thread.start()
        
        return False
    
    def _launch_cdp_thread(self):
        """Thread function to launch CDP"""
        success, message = self._launch_cdp_browser()
        
        if success:
            GLib.idle_add(self._set_status, "CDP browser ready")
            GLib.idle_add(self._init_ai)
        else:
            GLib.idle_add(self._show_cdp_error, message)
    
    def _show_cdp_error(self, message):
        """Show error dialog for CDP failure"""
        dialog = Adw.MessageDialog.new(
            self,
            "CDP Browser Not Available",
            message
        )
        dialog.add_response("ok", "OK")
        dialog.set_default_response("ok")
        dialog.set_close_response("ok")
        
        # Add details
        dialog.set_body(
            f"{message}\n\n"
            "Please launch the CDP browser manually:\n"
            "~/dev/ai_app/shared/scripts/launch_cdp.sh"
        )
        
        dialog.present()
        self._set_status("Error: CDP browser not available")
        return False


